---
layout: post
title: Basics of REST Web Services
type: post
tags:
 - java
published: false
draft: true
meta:
categories:
 - blog
---

<p>Came across this wonderful <a href="http://www.ibm.com/developerworks/webservices/library/ws-restful/" target="_blank">post</a> of why and when should REST be used and the simple basics of 2000s which has re-invented itself to better serve the needs of multi-application platforms. </p><p>&nbsp; </p><p>REST defines a set of architectural principles by which you can design Web services that focus on a system's resources, including how resource states are addressed and transferred over HTTP by a wide range of clients written in different languages. If measured by the number of Web services that use it, REST has emerged in the last few years alone as a predominant Web service design model. In fact, REST has had such a large impact on the Web that it has mostly displaced SOAP- and WSDL-based interface design because it's a considerably simpler style to use.  </p><p>REST didn't attract this much attention when it was first introduced in 2000 by Roy Fielding at the University of California, Irvine, in his academic dissertation, "Architectural Styles and the Design of Network-based Software Architectures," which analyzes a set of software architecture principles that use the Web as a platform for distributed computing (see <a href="http://www.ibm.com/developerworks/webservices/library/ws-restful/#resources">Resources</a> for a link to this dissertation). Now, years after its introduction, major frameworks for REST have started to appear and are still being developed because it's slated, for example, to become an integral part of Java™ 6 through JSR-311.  </p><p>This article suggests that in its purest form today, when it's attracting this much attention, a concrete implementation of a REST Web service follows four basic design principles:  <ul> <li>Use HTTP methods explicitly.  </li><li>Be stateless.  </li><li>Expose directory structure-like URIs.  </li><li>Transfer XML, JavaScript Object Notation (JSON), or both.</li></ul> </p><p>The following sections expand on these four principles and propose a technical rationale for why they might be important for REST Web service designers.  </p><p><strong><u>Use HTTP methods explicitly </u></strong> </p><p>One of the key characteristics of a RESTful Web service is the explicit use of HTTP methods in a way that follows the protocol as defined by RFC 2616. HTTP GET, for instance, is defined as a data-producing method that's intended to be used by a client application to retrieve a resource, to fetch data from a Web server, or to execute a query with the expectation that the Web server will look for and respond with a set of matching resources.  </p><p>REST asks developers to use HTTP methods explicitly and in a way that's consistent with the protocol definition. This basic REST design principle establishes a one-to-one mapping between create, read, update, and delete (CRUD) operations and HTTP methods. According to this mapping:  <ul> <li>To create a resource on the server, use POST.  </li><li>To retrieve a resource, use GET.  </li><li>To change the state of a resource or to update it, use PUT.  </li><li>To remove or delete a resource, use DELETE.</li></ul> </p><p>An unfortunate design flaw inherent in many Web APIs is in the use of HTTP methods for unintended purposes. The request URI in an HTTP GET request, for example, usually identifies one specific resource. Or the query string in a request URI includes a set of parameters that defines the search criteria used by the server to find a set of matching resources. At least this is how the HTTP/1.1 RFC describes GET. But there are many cases of unattractive Web APIs that use HTTP GET to trigger something transactional on the server—for instance, to add records to a database. In these cases the GET request URI is not used properly or at least not used RESTfully. If the Web API uses GET to invoke remote procedures, it looks like this:<br />GET /adduser?name=Robert HTTP/1.1  </p><p>It's not a very attractive design because the Web method above supports a state-changing operation over HTTP GET. Put another way, the HTTP GET request above has side effects. If successfully processed, the result of the request is to add a new user—in this example, Robert—to the underlying data store. The problem here is mainly semantic. Web servers are designed to respond to HTTP GET requests by retrieving resources that match the path (or the query criteria) in the request URI and return these or a representation in a response, not to add a record to a database. From the standpoint of the intended use of the protocol method then, and from the standpoint of HTTP/1.1-compliant Web servers, using GET in this way is inconsistent.  </p><p>Beyond the semantics, the other problem with GET is that to trigger the deletion, modification, or addition of a record in a database, or to change server-side state in some way, it invites Web caching tools (crawlers) and search engines to make server-side changes unintentionally simply by crawling a link. A simple way to overcome this common problem is to move the parameter names and values on the request URI into XML tags. The resulting tags, an XML representation of the entity to create, may be sent in the body of an HTTP POST whose request URI is the intended parent of the entity (see Listings 1 and 2).  </p><p><strong><u>Before</u></strong> </p><p> <table border="0" cellspacing="0" cellpadding="0"> <tbody> <tr> <td> <p>GET /adduser?name=Robert HTTP/1.1</p></td></tr></tbody></table> </p><p><strong><u>After</u></strong> <table border="0" cellspacing="0" cellpadding="0"> <tbody> <tr> <td> <p>POST /users HTTP/1.1  </p><p>Host: myserver  </p><p>Content-Type: application/xml  </p><p>&lt;?xml version="1.0"?&gt;  </p><p>&lt;user&gt;  </p><p>&lt;name&gt;Robert&lt;/name&gt;  </p><p>&lt;/user&gt;</p></td></tr></tbody></table> </p><p>The method above is exemplary of a RESTful request: proper use of HTTP POST and inclusion of the payload in the body of the request. On the receiving end, the request may be processed by adding the resource contained in the body as a subordinate of the resource identified in the request URI; in this case the new resource should be added as a child of /users. This containment relationship between the new entity and its parent, as specified in the POST request, is analogous to the way a file is subordinate to its parent directory. The client sets up the relationship between the entity and its parent and defines the new entity's URI in the POST request.  </p><p>A client application may then get a representation of the resource using the new URI, noting that at least logically the resource is located under /users, as shown. </p><p> <table border="0" cellspacing="0" cellpadding="0"> <tbody> <tr> <td> <p>GET /users/Robert HTTP/1.1  </p><p>Host: myserver  </p><p>Accept: application/xml</p></td></tr></tbody></table> </p><p>Using GET in this way is explicit because GET is for data retrieval only. GET is an operation that should be free of side effects, a property also known as <i>idempotence</i>.  </p><p>A similar refactoring of a Web method also needs to be applied in cases where an update operation is supported over HTTP GET, as shown. </p><p> <table border="0" cellspacing="0" cellpadding="0"> <tbody> <tr> <td> <p>GET /updateuser?name=Robert&amp;newname=Bob HTTP/1.1</p></td></tr></tbody></table> </p><p>This changes the name attribute (or property) of the resource. While the query string can be used for such an operation, and Listing 4 is a simple one, this query-string-as-method-signature pattern tends to break down when used for more complex operations. Because your goal is to make explicit use of HTTP methods, a more RESTful approach is to send an HTTP PUT request to update the resource, instead of HTTP GET, for the same reasons stated above. </p><p> <table border="0" cellspacing="0" cellpadding="0"> <tbody> <tr> <td> <p>PUT /users/Robert HTTP/1.1  </p><p>Host: myserver  </p><p>Content-Type: application/xml  </p><p>&lt;?xml version="1.0"?&gt;  </p><p>&lt;user&gt;  </p><p>&lt;name&gt;Bob&lt;/name&gt;  </p><p>&lt;/user&gt;</p></td></tr></tbody></table> </p><p>Using PUT to replace the original
 resource provides a much cleaner interface that's consistent with REST's principles and with the definition of HTTP methods. The PUT request in Listing 5 is explicit in the sense that it points at the resource to be updated by identifying it in the request URI and in the sense that it transfers a new representation of the resource from client to server in the body of a PUT request instead of transferring the resource attributes as a loose set of parameter names and values on the request URI. Listing 5 also has the effect of renaming the resource from Robert to Bob, and in doing so changes its URI to/users/Bob. In a REST Web service, subsequent requests for the resource using the old URI would generate a standard 404 Not Found error.  </p><p>As a general design principle, it helps to follow REST guidelines for using HTTP methods explicitly by using nouns in URIs instead of verbs. In a RESTful Web service, the verbs—POST, GET, PUT, and DELETE—are already defined by the protocol. And ideally, to keep the interface generalized and to allow clients to be explicit about the operations they invoke, the Web service should not define more verbs or remote procedures, such as /adduser or /updateuser. This general design principle also applies to the body of an HTTP request, which is intended to be used to transfer resource state, not to carry the name of a remote method or remote procedure to be invoked.  </p><p><strong><u>Be Stateless</u></strong> </p><p>REST Web services need to scale to meet increasingly high performance demands. Clusters of servers with load-balancing and failover capabilities, proxies, and gateways are typically arranged in a way that forms a service topology, which allows requests to be forwarded from one server to the other as needed to decrease the overall response time of a Web service call. Using intermediary servers to improve scale requires REST Web service clients to send complete, independent requests; that is, to send requests that include all data needed to be fulfilled so that the components in the intermediary servers may forward, route, and load-balance without any state being held locally in between requests.  </p><p>A complete, independent request doesn't require the server, while processing the request, to retrieve any kind of application context or state. A REST Web service application (or client) includes within the HTTP headers and body of a request all of the parameters, context, and data needed by the server-side component to generate a response. Statelessness in this sense improves Web service performance and simplifies the design and implementation of server-side components because the absence of state on the server removes the need to synchronize session data with an external application.  </p><p>Figure 1 illustrates a stateful service from which an application may request the next page in a multipage result set, assuming that the service keeps track of where the application leaves off while navigating the set. In this stateful design, the service increments and stores a previousPage variable somewhere to be able to respond to requests for next.  </p><p><strong><u>Stateful Design</u></strong> </p><p><a href="http://blog.zenhacking.com/wp-content/uploads/2011/09/clip_image00112.gif"><img style="border-bottom:0;border-left:0;display:inline;border-top:0;border-right:0;" title="clip_image001" border="0" alt="clip_image001" src="http://blog.zenhacking.com/wp-content/uploads/2011/09/clip_image001_thumb12.gif" width="701" height="199" /></a>  </p><p>Stateful services like this get complicated. In a Java Platform, Enterprise Edition (Java EE) environment stateful services require a lot of up-front consideration to efficiently store and enable the synchronization of session data across a cluster of Java EE containers. In this type of environment, there's a problem familiar to servlet/JavaServer Pages (JSP) and Enterprise JavaBeans (EJB) developers who often struggle to find the root causes of java.io.NotSerializableException during session replication. Whether it's thrown by the servlet container during HttpSession replication or thrown by the EJB container during stateful EJB replication, it's a problem that can cost developers days in trying to pinpoint the one object that doesn't implementSerializable in a sometimes complex graph of objects that constitute the server's state. In addition, session synchronization adds overhead, which impacts server performance.  </p><p>Stateless server-side components, on the other hand, are less complicated to design, write, and distribute across load-balanced servers. A stateless service not only performs better, it shifts most of the responsibility of maintaining state to the client application. In a RESTful Web service, the server is responsible for generating responses and for providing an interface that enables the client to maintain application state on its own. For example, in the request for a multipage result set, the client should include the actual page number to retrieve instead of simply asking for <i>next</i> (see Figure 2).  </p><p><strong><u>Stateless Design</u></strong> </p><p><a href="http://blog.zenhacking.com/wp-content/uploads/2011/09/clip_image00212.gif"><img style="border-bottom:0;border-left:0;display:inline;border-top:0;border-right:0;" title="clip_image002" border="0" alt="clip_image002" src="http://blog.zenhacking.com/wp-content/uploads/2011/09/clip_image002_thumb11.gif" width="663" height="188" /></a>  </p><p>A stateless Web service generates a response that links to the next page number in the set and lets the client do what it needs to in order to keep this value around. This aspect of RESTful Web service design can be broken down into two sets of responsibilities as a high-level separation that clarifies just how a stateless service can be maintained:  </p><p><b>Server</b>  <ul> <li>Generates responses that include links to other resources to allow applications to navigate between related resources. This type of response embeds links. Similarly, if the request is for a parent or container resource, then a typical RESTful response might also include links to the parent's children or subordinate resources so that these remain connected.  </li><li>Generates responses that indicate whether they are cacheable or not to improve performance by reducing the number of requests for duplicate resources and by eliminating some requests entirely. The server does this by including a Cache-Control and Last-Modified (a date value) HTTP response header.</li></ul> </p><p><b>Client application</b>  <ul> <li>Uses the Cache-Control response header to determine whether to cache the resource (make a local copy of it) or not. The client also reads the Last-Modified response header and sends back the date value in an If-Modified-Since header to ask the server if the resource has changed. This is called Conditional GET, and the two headers go hand in hand in that the server's response is a standard 304 code (Not Modified) and omits the actual resource requested if it has not changed since that time. A 304 HTTP response code means the client can safely use a cached, local copy of the resource representation as the most up-to-date, in effect bypassing subsequent GET requests until the resource changes.  </li><li>Sends complete requests that can be serviced independently of other requests. This requires the client to make full use of HTTP headers as specified by the Web service interface and to send complete representations of resources in the request body. The client sends requests that make very few assumptions about prior requests, the existence of a session on the server, the server's ability to add context to a request, or about application state that is kept in between requests.</li></ul> </p><p>This collaboration between client application and service is essential to being stateless in a RESTful Web service. It improves performance by saving bandwidth and minimizing server-side application state.  </p><p><strong><u>Expose directory structure-like URIs </u></strong> </p><p>From the standpoint of client applications addressing resources, the URIs determine how intuitive the REST Web service is going to be and
whether the service is going to be used in ways that the designers can anticipate. A third RESTful Web service characteristic is all about the URIs.  </p><p>REST Web service URIs should be intuitive to the point where they are easy to guess. Think of a URI as a kind of self-documenting interface that requires little, if any, explanation or reference for a developer to understand what it points to and to derive related resources. To this end, the structure of a URI should be straightforward, predictable, and easily understood.  </p><p>One way to achieve this level of usability is to define directory structure-like URIs. This type of URI is hierarchical, rooted at a single path, and branching from it are subpaths that expose the service's main areas. According to this definition, a URI is not merely a slash-delimited string, but rather a tree with subordinate and superordinate branches connected at nodes. For example, in a discussion threading service that gathers topics ranging from Java to paper, you might define a structured set of URIs like this:<br />http://www.myservice.org/discussion/topics/{topic}  </p><p>The root, /discussion, has a /topics node beneath it. Underneath that there are a series of topic names, such as gossip, technology, and so on, each of which points to a discussion thread. Within this structure, it's easy to pull up discussion threads just by typing something after /topics/.  </p><p>In some cases, the path to a resource lends itself especially well to a directory-like structure. Take resources organized by date, for instance, which are a very good match for using a hierarchical syntax.  </p><p>This example is intuitive because it is based on rules:<br />http://www.myservice.org/discussion/2008/12/10/{topic}  </p><p>The first path fragment is a four-digit year, the second path fragment is a two-digit day, and the third fragment is a two-digit month. It may seem a little silly to explain it that way, but this is the level of simplicity we're after. Humans and machines can easily generate structured URIs like this because they are based on rules. Filling in the path parts in the slots of a syntax makes them good because there is a definite pattern from which to compose them:<br />http://www.myservice.org/discussion/{year}/{day}/{month}/{topic}  </p><p>Some additional guidelines to make note of while thinking about URI structure for a RESTful Web service are:  <ul> <li>Hide the server-side scripting technology file extensions (.jsp, .php, .asp), if any, so you can port to something else without changing the URIs.  </li><li>Keep everything lowercase.  </li><li>Substitute spaces with hyphens or underscores (one or the other).  </li><li>Avoid query strings as much as you can.  </li><li>Instead of using the 404 Not Found code if the request URI is for a partial path, always provide a default page or resource as a response.</li></ul> </p><p>URIs should also be static so that when the resource changes or the implementation of the service changes, the link stays the same. This allows bookmarking. It's also important that the relationship between resources that's encoded in the URIs remains independent of the way the relationships are represented where they are stored.  </p><p><strong><u>Transfer XML, JSON, or both </u></strong> </p><p>A resource representation typically reflects the current state of a resource, and its attributes, at the time a client application requests it. Resource representations in this sense are mere snapshots in time. This could be a thing as simple as a representation of a record in a database that consists of a mapping between column names and XML tags, where the element values in the XML contain the row values. Or, if the system has a data model, then according to this definition a resource representation is a snapshot of the attributes of one of the things in your system's data model. These are the things you want your REST Web service to serve up.  </p><p>The last set of constraints that goes into a RESTful Web service design has to do with the format of the data that the application and service exchange in the request/response payload or in the HTTP body. This is where it really pays to keep things simple, human-readable, and connected.  </p><p>The objects in your data model are usually related in some way, and the relationships between data model objects (resources) should be reflected in the way they are represented for transfer to a client application. In the discussion threading service, an example of connected resource representations might include a root discussion topic and its attributes, and embed links to the responses given to that topic.  </p><p> <table border="0" cellspacing="0" cellpadding="0"> <tbody> <tr> <td> <p>&lt;?xml version="1.0"?&gt;  </p><p>&lt;discussion date="{date}" topic="{topic}"&gt;  </p><p>&lt;comment&gt;{comment}&lt;/comment&gt;  </p><p>&lt;replies&gt;  </p><p>&lt;reply from="joe@mail.com" href="/discussion/topics/{topic}/joe"/&gt;  </p><p>&lt;reply from="bob@mail.com" href="/discussion/topics/{topic}/bob"/&gt;  </p><p>&lt;/replies&gt;  </p><p>&lt;/discussion&gt;</p></td></tr></tbody></table> </p><p>And last, to give client applications the ability to request a specific content type that's best suited for them, construct your service so that it makes use of the built-in HTTP Accept header, where the value of the header is a MIME type. Some common MIME types used by RESTful services are shown in Table 1.  </p><p> <table border="1" cellspacing="0" cellpadding="0"> <tbody> <tr> <td valign="top"> <p><b>MIME-Type</b></p></td> <td valign="top"> <p><b>Content-Type</b></p></td></tr> <tr> <td valign="top"> <p><b>JSON</b></p></td> <td valign="top"> <p>application/json</p></td></tr> <tr> <td valign="top"> <p><b>XML</b></p></td> <td valign="top"> <p>application/xml</p></td></tr> <tr> <td valign="top"> <p><b>XHTML</b></p></td> <td valign="top"> <p>application/xhtml+xml</p></td></tr></tbody></table> </p><p>This allows the service to be used by a variety of clients written in different languages running on different platforms and devices. Using MIME types and the HTTP Accept header is a mechanism known as <i>content negotiation</i>, which lets clients choose which data format is right for them and minimizes data coupling between the service and the applications that use it.  </p><p><strong><u>Conclusion </u></strong> </p><p>REST is not always the right choice. It has caught on as a way to design Web services with less dependence on proprietary middleware (for example, an application server) than the SOAP- and WSDL-based kind. And in a sense, REST is a return to the Web the way it was before the age of the big application server, through its emphasis on the early Internet standards, URI and HTTP. As you've examined in the so-called principles of RESTful interface design, XML over HTTP is a powerful interface that allows internal applications, such as Asynchronous JavaScript + XML (Ajax)-based custom user interfaces, to easily connect, address, and consume resources. In fact, the great fit between Ajax and REST has increased the amount of attention REST is getting these days.  </p><p>Exposing a system's resources through a RESTful API is a flexible way to provide different kinds of applications with data formatted in a standard way. It helps to meet integration requirements that are critical to building systems where data can be easily combined (mashups) and to extend or build on a set of base, RESTful services into something much bigger. This article touches on just the basics here but hopefully in a way that has enticed you to continue exploring the subject.</p>
