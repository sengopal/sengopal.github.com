<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Senthilkumar Gopal - Coding</title><link href="https://sengopal.github.io/" rel="alternate"></link><link href="https://sengopal.github.io/feeds/coding.atom.xml" rel="self"></link><id>https://sengopal.github.io/</id><updated>2023-02-20T00:00:00-08:00</updated><subtitle>Musings of a machine learning researcher, engineer and leader</subtitle><entry><title>float16 precision conversion to Base64</title><link href="https://sengopal.github.io/posts/float16-precision-conversion-to-base64.html" rel="alternate"></link><published>2023-02-20T00:00:00-08:00</published><updated>2023-02-20T00:00:00-08:00</updated><author><name>Senthilkumar Gopal</name></author><id>tag:sengopal.github.io,2023-02-20:/posts/float16-precision-conversion-to-base64.html</id><summary type="html">This post discusses the different methods in Python for converting float16 or half-precision floats to base64 and vice versa to ensure lossless transmission of numpy array data.</summary><content type="html">&lt;p&gt;With the advent of vector databases and large model based embeddings,
with dimensions of 768 and 2048, building large scale indexes for
performing ANN and storing these vectors have become expensive
operations. There are many methods of reducing the vector&amp;rsquo;s memory
footprint such as quantization or even int8. Two such well used methods
are binarization and using half-precision or float16 to store these
vectors. The following are simple code snippets that I collected from
various sources for conversion between these formats to base64 to ensure
lossless transmission over the wire, such as HTTP services.&lt;/p&gt;
&lt;h2 id="binarization"&gt;Binarization&lt;/h2&gt;
&lt;p&gt;Binarization is a simple method which works well for large
dimensional vectors. There are many methods to define the threshold such
as mean or median values per dimension etc., The below is an example of
storing a binary vector as base64 and back, packed in blocks, where each
block consists of 8 bits.&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb1-1"&gt;&lt;a aria-hidden="true" href="#cb1-1" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; base64_to_binary_vec(s):&lt;/span&gt;
&lt;span id="cb1-2"&gt;&lt;a aria-hidden="true" href="#cb1-2" tabindex="-1"&gt;&lt;/a&gt;    binary &lt;span class="op"&gt;=&lt;/span&gt; base64.b64decode(s)&lt;/span&gt;
&lt;span id="cb1-3"&gt;&lt;a aria-hidden="true" href="#cb1-3" tabindex="-1"&gt;&lt;/a&gt;    bits &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="bu"&gt;bin&lt;/span&gt;(byte)[&lt;span class="dv"&gt;2&lt;/span&gt;:].zfill(&lt;span class="dv"&gt;8&lt;/span&gt;) &lt;span class="cf"&gt;for&lt;/span&gt; byte &lt;span class="kw"&gt;in&lt;/span&gt; binary]&lt;/span&gt;
&lt;span id="cb1-4"&gt;&lt;a aria-hidden="true" href="#cb1-4" tabindex="-1"&gt;&lt;/a&gt;    s_bits &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;''&lt;/span&gt;.join(bits)&lt;/span&gt;
&lt;span id="cb1-5"&gt;&lt;a aria-hidden="true" href="#cb1-5" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# print(len(s_bits))&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-6"&gt;&lt;a aria-hidden="true" href="#cb1-6" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; s_bits&lt;/span&gt;
&lt;span id="cb1-7"&gt;&lt;a aria-hidden="true" href="#cb1-7" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-8"&gt;&lt;a aria-hidden="true" href="#cb1-8" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-9"&gt;&lt;a aria-hidden="true" href="#cb1-9" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; convert_binary_tob64(s_vec):&lt;/span&gt;
&lt;span id="cb1-10"&gt;&lt;a aria-hidden="true" href="#cb1-10" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; base64.b64encode(s_vec).decode(&lt;span class="st"&gt;"utf-8"&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb1-11"&gt;&lt;a aria-hidden="true" href="#cb1-11" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-12"&gt;&lt;a aria-hidden="true" href="#cb1-12" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; verify_binary_encoding():&lt;/span&gt;
&lt;span id="cb1-13"&gt;&lt;a aria-hidden="true" href="#cb1-13" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# binary vector - example 1&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-14"&gt;&lt;a aria-hidden="true" href="#cb1-14" tabindex="-1"&gt;&lt;/a&gt;    sample_cons_str &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;"D/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A=="&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-15"&gt;&lt;a aria-hidden="true" href="#cb1-15" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(base64_to_binary_vec(sample_cons_str))&lt;/span&gt;
&lt;span id="cb1-16"&gt;&lt;a aria-hidden="true" href="#cb1-16" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-17"&gt;&lt;a aria-hidden="true" href="#cb1-17" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# binary vector - example 2&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-18"&gt;&lt;a aria-hidden="true" href="#cb1-18" tabindex="-1"&gt;&lt;/a&gt;    test_str &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;'vckIkrUOV/sgvGYNBfCLEimBkRMSSGxA2TESPj7ixDZNofUdJVChxmwDCSKV4TG8EYwQUhOWtRGzMjJ6LbLaVe2nCBJn3wN1LIFwA2ikTpP5DrRCBDFdVYxBkuAKARelzQRNE4QTRLm8WKbMLE1AYLgHpIy1bTtB6tGPRvU6adxDSVjDRlA9XNMlsg0NMB5tRKzLiHoUbwz8B+oNzcC/lA8I3CNyY8JD6kT1eN2Vq+Xt4eTm6AZL3/Cs9lYeG4tjjuzK0ioVMyAaStmsp2MchziKUoYShVQ2qH2HgLoRD9kJjUL7AoBzMivoZTi4jaUfVn6HooiDvAfZt8CpHqxQ0A=='&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-19"&gt;&lt;a aria-hidden="true" href="#cb1-19" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(base64_to_binary_vec(test_str))&lt;/span&gt;
&lt;span id="cb1-20"&gt;&lt;a aria-hidden="true" href="#cb1-20" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-21"&gt;&lt;a aria-hidden="true" href="#cb1-21" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# binary vector - example 3 - to reconstruct the vector&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-22"&gt;&lt;a aria-hidden="true" href="#cb1-22" tabindex="-1"&gt;&lt;/a&gt;    s_vec &lt;span class="op"&gt;=&lt;/span&gt; []&lt;/span&gt;
&lt;span id="cb1-23"&gt;&lt;a aria-hidden="true" href="#cb1-23" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;2048&lt;/span&gt; &lt;span class="op"&gt;//&lt;/span&gt; (&lt;span class="dv"&gt;8&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)):&lt;/span&gt;
&lt;span id="cb1-24"&gt;&lt;a aria-hidden="true" href="#cb1-24" tabindex="-1"&gt;&lt;/a&gt;        s_vec &lt;span class="op"&gt;+=&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/span&gt;
&lt;span id="cb1-25"&gt;&lt;a aria-hidden="true" href="#cb1-25" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-26"&gt;&lt;a aria-hidden="true" href="#cb1-26" tabindex="-1"&gt;&lt;/a&gt;    b64_str &lt;span class="op"&gt;=&lt;/span&gt; convert_binary_tob64(s_vec)&lt;/span&gt;
&lt;span id="cb1-27"&gt;&lt;a aria-hidden="true" href="#cb1-27" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# print(b64_str)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-28"&gt;&lt;a aria-hidden="true" href="#cb1-28" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;assert&lt;/span&gt; (b64_str &lt;span class="op"&gt;==&lt;/span&gt; sample_cons_str)&lt;/span&gt;
&lt;span id="cb1-29"&gt;&lt;a aria-hidden="true" href="#cb1-29" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-30"&gt;&lt;a aria-hidden="true" href="#cb1-30" tabindex="-1"&gt;&lt;/a&gt;    s_vec_recreate &lt;span class="op"&gt;=&lt;/span&gt; base64_to_binary_vec(b64_str)&lt;/span&gt;
&lt;span id="cb1-31"&gt;&lt;a aria-hidden="true" href="#cb1-31" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# print(len(s_vec_recreate))&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-32"&gt;&lt;a aria-hidden="true" href="#cb1-32" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# print(s_vec_recreate)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-33"&gt;&lt;a aria-hidden="true" href="#cb1-33" tabindex="-1"&gt;&lt;/a&gt;    s_vec_expected &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;''&lt;/span&gt;.join([&lt;span class="st"&gt;'0'&lt;/span&gt; &lt;span class="cf"&gt;if&lt;/span&gt; val &lt;span class="cf"&gt;else&lt;/span&gt; &lt;span class="st"&gt;'1'&lt;/span&gt; &lt;span class="cf"&gt;for&lt;/span&gt; val &lt;span class="kw"&gt;in&lt;/span&gt; s_vec])&lt;/span&gt;
&lt;span id="cb1-34"&gt;&lt;a aria-hidden="true" href="#cb1-34" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# print(s_vec_expected)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-35"&gt;&lt;a aria-hidden="true" href="#cb1-35" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;assert&lt;/span&gt;(s_vec_recreate &lt;span class="op"&gt;==&lt;/span&gt; s_vec_expected)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="float-16-to-base64-conversion"&gt;Float 16 to Base64
conversion&lt;/h2&gt;
&lt;p&gt;The below is an example of storing a float 16 vector as base64 and
back to the float16 vector without any loss of data.&lt;/p&gt;
&lt;p&gt;There are multiple methods for float16 to base64 conversion.&lt;/p&gt;
&lt;h3 id="method-1---using-numpy-buffer"&gt;Method 1 - using Numpy
buffer&lt;/h3&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb2-1"&gt;&lt;a aria-hidden="true" href="#cb2-1" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; convert_f16_to_b64_m1(arr):&lt;/span&gt;
&lt;span id="cb2-2"&gt;&lt;a aria-hidden="true" href="#cb2-2" tabindex="-1"&gt;&lt;/a&gt;    a &lt;span class="op"&gt;=&lt;/span&gt; np.array(arr, np.float16)&lt;/span&gt;
&lt;span id="cb2-3"&gt;&lt;a aria-hidden="true" href="#cb2-3" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; base64.b64encode(a.tobytes())&lt;/span&gt;
&lt;span id="cb2-4"&gt;&lt;a aria-hidden="true" href="#cb2-4" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-5"&gt;&lt;a aria-hidden="true" href="#cb2-5" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; convert_b64_to_f16(emb):&lt;/span&gt;
&lt;span id="cb2-6"&gt;&lt;a aria-hidden="true" href="#cb2-6" tabindex="-1"&gt;&lt;/a&gt;    binary &lt;span class="op"&gt;=&lt;/span&gt; base64.b64decode(emb)&lt;/span&gt;
&lt;span id="cb2-7"&gt;&lt;a aria-hidden="true" href="#cb2-7" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(binary)&lt;/span&gt;
&lt;span id="cb2-8"&gt;&lt;a aria-hidden="true" href="#cb2-8" tabindex="-1"&gt;&lt;/a&gt;    q &lt;span class="op"&gt;=&lt;/span&gt; np.frombuffer(binary, dtype&lt;span class="op"&gt;=&lt;/span&gt;np.float16)&lt;/span&gt;
&lt;span id="cb2-9"&gt;&lt;a aria-hidden="true" href="#cb2-9" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(q.shape)&lt;/span&gt;
&lt;span id="cb2-10"&gt;&lt;a aria-hidden="true" href="#cb2-10" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; q&lt;/span&gt;
&lt;span id="cb2-11"&gt;&lt;a aria-hidden="true" href="#cb2-11" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-12"&gt;&lt;a aria-hidden="true" href="#cb2-12" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; verify_f16_encoding_m1():&lt;/span&gt;
&lt;span id="cb2-13"&gt;&lt;a aria-hidden="true" href="#cb2-13" tabindex="-1"&gt;&lt;/a&gt;    b64_emb &lt;span class="op"&gt;=&lt;/span&gt; convert_f16_to_b64_m1([&lt;span class="fl"&gt;1.2345&lt;/span&gt;])&lt;/span&gt;
&lt;span id="cb2-14"&gt;&lt;a aria-hidden="true" href="#cb2-14" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;assert&lt;/span&gt; (np.isclose([&lt;span class="fl"&gt;1.2345&lt;/span&gt;], convert_b64_to_f16(b64_emb), atol&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1e-2&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="method-2---using-struct-pack"&gt;Method 2 - using Struct pack&lt;/h3&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb3-1"&gt;&lt;a aria-hidden="true" href="#cb3-1" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; convert_f16_to_b64_m2(arr):&lt;/span&gt;
&lt;span id="cb3-2"&gt;&lt;a aria-hidden="true" href="#cb3-2" tabindex="-1"&gt;&lt;/a&gt;    packer &lt;span class="op"&gt;=&lt;/span&gt; struct.Struct(&lt;span class="st"&gt;"&amp;lt;96e"&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb3-3"&gt;&lt;a aria-hidden="true" href="#cb3-3" tabindex="-1"&gt;&lt;/a&gt;    vector_array &lt;span class="op"&gt;=&lt;/span&gt; np.array(arr, dtype&lt;span class="op"&gt;=&lt;/span&gt;np.float16).tolist()&lt;/span&gt;
&lt;span id="cb3-4"&gt;&lt;a aria-hidden="true" href="#cb3-4" tabindex="-1"&gt;&lt;/a&gt;    vector_bytes &lt;span class="op"&gt;=&lt;/span&gt; packer.pack(&lt;span class="op"&gt;*&lt;/span&gt;vector_array)&lt;/span&gt;
&lt;span id="cb3-5"&gt;&lt;a aria-hidden="true" href="#cb3-5" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; base64.b64encode(vector_bytes)&lt;/span&gt;
&lt;span id="cb3-6"&gt;&lt;a aria-hidden="true" href="#cb3-6" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-7"&gt;&lt;a aria-hidden="true" href="#cb3-7" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; verify_f16_encoding_m2():&lt;/span&gt;
&lt;span id="cb3-8"&gt;&lt;a aria-hidden="true" href="#cb3-8" tabindex="-1"&gt;&lt;/a&gt;    arr &lt;span class="op"&gt;=&lt;/span&gt; np.random.normal(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="fl"&gt;0.01&lt;/span&gt;, &lt;span class="dv"&gt;96&lt;/span&gt;).astype(&lt;span class="st"&gt;'float16'&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb3-9"&gt;&lt;a aria-hidden="true" href="#cb3-9" tabindex="-1"&gt;&lt;/a&gt;    b64_emb &lt;span class="op"&gt;=&lt;/span&gt; convert_f16_to_b64_m2(&lt;span class="bu"&gt;list&lt;/span&gt;(arr))&lt;/span&gt;
&lt;span id="cb3-10"&gt;&lt;a aria-hidden="true" href="#cb3-10" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;assert&lt;/span&gt;(np.isclose(arr, convert_b64_to_f16(b64_emb), atol&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1e-2&lt;/span&gt;).&lt;span class="bu"&gt;all&lt;/span&gt;())&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="method-3---using-dtype-indicator"&gt;Method 3 - using dtype
indicator&lt;/h3&gt;
&lt;p&gt;Based on the method described at &lt;a href="https://numpy.org/doc/stable/reference/arrays.dtypes.html"&gt;arrays.dtypes.html&lt;/a&gt;,
&lt;code&gt;&amp;lt;f2&lt;/code&gt; is supposed to be faster than struct.&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb4-1"&gt;&lt;a aria-hidden="true" href="#cb4-1" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; convert_f16_to_b64_m3(arr):&lt;/span&gt;
&lt;span id="cb4-2"&gt;&lt;a aria-hidden="true" href="#cb4-2" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# using f2 is faster&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-3"&gt;&lt;a aria-hidden="true" href="#cb4-3" tabindex="-1"&gt;&lt;/a&gt;    a &lt;span class="op"&gt;=&lt;/span&gt; np.array(arr, dtype&lt;span class="op"&gt;=&lt;/span&gt;np.dtype(&lt;span class="st"&gt;'&amp;lt;f2'&lt;/span&gt;))&lt;/span&gt;
&lt;span id="cb4-4"&gt;&lt;a aria-hidden="true" href="#cb4-4" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; base64.b64encode(a.tobytes())&lt;/span&gt;
&lt;span id="cb4-5"&gt;&lt;a aria-hidden="true" href="#cb4-5" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb4-6"&gt;&lt;a aria-hidden="true" href="#cb4-6" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; verify_f16_encoding_m3():&lt;/span&gt;
&lt;span id="cb4-7"&gt;&lt;a aria-hidden="true" href="#cb4-7" tabindex="-1"&gt;&lt;/a&gt;    arr &lt;span class="op"&gt;=&lt;/span&gt; np.random.normal(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="fl"&gt;0.01&lt;/span&gt;, &lt;span class="dv"&gt;96&lt;/span&gt;).astype(&lt;span class="st"&gt;'float16'&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb4-8"&gt;&lt;a aria-hidden="true" href="#cb4-8" tabindex="-1"&gt;&lt;/a&gt;    b64_emb &lt;span class="op"&gt;=&lt;/span&gt; convert_f16_to_b64_m3(&lt;span class="bu"&gt;list&lt;/span&gt;(arr))&lt;/span&gt;
&lt;span id="cb4-9"&gt;&lt;a aria-hidden="true" href="#cb4-9" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;assert&lt;/span&gt;(np.isclose(arr, convert_b64_to_f16(b64_emb), atol&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1e-5&lt;/span&gt;).&lt;span class="bu"&gt;all&lt;/span&gt;())&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;The same can be achieved using &lt;a href="https://stackoverflow.com/questions/6162651/half-precision-floating-point-in-java"&gt;Java/Scala&lt;/a&gt;
as well.&lt;/p&gt;
&lt;h3 id="citation"&gt;Citation&lt;/h3&gt;
&lt;p&gt;To refer to this post, please cite it as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Float16 precision conversion to Base64 for lossless transmission | Senthilkumar Gopal. 
https://sengopal.github.io/posts/float16-precision-conversion-to-base64.html&lt;/code&gt;&lt;/pre&gt;</content><category term="Coding"></category><category term="backend"></category><category term="services"></category><category term="python"></category><category term="machine-learning"></category></entry></feed>