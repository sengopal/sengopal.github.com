= Good code and Why do we care?
Senthilkumar Gopal
2016-05-12
:jbake-type: post
:jbake-tags: architecture,coding
:jbake-status: draft
:summary: A post about the importance of writing good code with not just quality, but asthetics, readability and predictability.

As a developer, writing code is an activity that we do day-in, day-out. However, unlike a sculptor who carves his work, most of the time, we go about grabbing code snippets and stiching up a patched dress instead of a Armani or a Ralph Lauren.

We never care about finess as we don't value the code that we produce on the same lines of an artist with his fine brush strokes. Recently i came across a [blog post](http://blog.d3in.org/post/130288777151/10-principles-for-good-code) which attempts to list reasons to consider your code a

> canvas for your artwork rather than a boring task to get over with.

Some of the characteristics that we definitely need to ensure that our code act as:

1. Simplest as possible
2. Asthetic and consistent
3. Help understand the Product function
4. Commented for reason

== 1.Simplest as possible ==
One of the sayings that we have in our team is

> The best bug-free code is the one which is never written.

Before writing any piece of code, check the same is already available, as part of your code base or external libraries. The simplest reason being it would have been definitely tested, does not need additional junits in our code base and definitely has lot less bugs that the code that we would write to perform the same function. Quite a few times, there might be minor discrepancies in terms of parameters, types. In that case, as a seasoned developer, try to weigh in the options of if its really necessary to recreate or if your code should actually be using the parameter structure of the established library.

My personal preference is

> Even in case, if its not directly usable, attempt to verify if the re-usable code can be best aligned by minor changes in your code base.

== 2. Asthetic and consistent ==
There are so many style guides, such as from https://google.github.io/styleguide/javaguide.html[Google] or even from http://www.oracle.com/technetwork/java/codeconvtoc-136057.html[Oracle] itself. However, it doesn't really matter which one as long as the team agrees and adheres to it. One of the easiest ways to ensure consistency is to use Eclipse Formatter or Intellj Idea preferences or similar common formatters for the IDE of your teams choice.

=== Why is this important? ===
Assume the team is working on a code base consisting of thousands of files and someone is attempting to identify a bug in the middle of the night. *It would be better to have a line width of 200 rather than a line width of 80 and half the screen white and needing the developer to scroll multiple times to view a single function.*

Irrespective of the formatter rules, there are few common and mostly sensible practices that we follow.

1. Never have a function span more than 10-15 lines of code.
2. Ensure each function performs only one action
3. Name the function appropriately.
4. Remember the types of parameters or parameter names are not necessary in the function name. For example, it is better to name a function add(int i, int j) rather than addIntegers(int i, int j)
5. One other quirk is to not have the return parameter type or name as part of the function name. For Example: public JSONObject convertStringToJSONObject(String s) is better named as public JSONObject convert(String s).
6. Ensure that your class encapsulates the function of one object.
7. Ideally any class should have at a maximum of 6 or 7 functions. If there are more check if refactoring to more atomic classes are needed.

=== Good code is aesthetic ===

__Inspired by http://blog.d3in.org/post/130288777151/10-principles-for-good-code[principles of good code]__

Any product created should have its purpose served best by its utility. From a simple spoon to a complex rocket ship can be appreciated of its beauty only if its usefulness is completely appreciated. Aesthetic structure is not just for web or native applications, but also for API designs, code written, even for comments.

Maintaining symmetry and consistency is appreciated if it serves its usefulness, similar to:

1. Code style Consistency
3. Absence of unstructured notes (TODO, FIXME, etc.)
4. Comments
5. Naming conventions
6. Conciseness
7. Reusability

“Code Is Hard to Read

By Dave Anderson

Each programmer has an idea in their head regarding hard to read and easy to read. Readability depends on many factors:

Implementation language. Some syntax just is easier to read than others. XSLT anyone?
Code layout and formatting. Personal preferences and pet hates, like “Where do I place the curly brace?” and indentation.
Naming conventions. userStatus versus _userstatus versus x.
Viewer. Choice of IDE, editor, or other tool used will contribute to readability.”

“Solution design. The most common problem – “I see what’s happening here… but it could be done better.”


“When you have the opportunity, try deodorizing the smelly code. Don’t rush. Just take small steps. In Martin Fowler’s Refactoring the steps of the refactorings presented are outlined in great detail, so it’s easy to follow. I would suggest doing the steps at least once manually to get a feeling for the preconditions and side effects of each refactoring. Thinking about what you’re doing is absolutely necessary when refactoring.”



Choosing DataTypes and parameters



Decouple the UI



Dont use too much magic

“n recent years convention over configuration has been an emerging software design paradigm. By taking advantage of it, developers only need specify the non-common part of their application, because the tools that follow this approach provide meaningful behavior for all the aspects covered by the tool itself. These default behaviors often fit the most typical needs. The defaults can be replaced by custom implementations where something more specific is needed. ”



“Execution Speed versus Maintenance Effort”



“Improved Testability Leads to Better Design”



Interface design
“The conclusion on this is that setters and getters are alien constructs that do not reveal the intention and responsibility of a behavior-centric interface. Therefore you should try to avoid using them; there are better alternatives.”


Complexity
“While a low line count is a good starting point, the overall cognitive load can be further reduced by keeping the cyclomatic complexity low – ideally under 3 or 4, definitely under 10. Cyclomatic complexity is a numeric value that can easily be computed by many tools and is roughly equivalent to the number of execution paths through a method. A high cyclomatic complexity complicates unit testing and has been empirically shown to correlate with bugs.”


Small Methods / Name methods



“The list of attributes I use (in no particular order) are:

Correctness: Does the code do its job?
Modifiability: How easy is the code to modify?
Performance: How fast does the code run? How much memory, disk space, CPU, network usage, etc. will it use?
Speed of production: How quickly will the code be constructed?
Reusability: To what degree will the code be architected to allow later projects to reuse code?
Approachability: How difficult is it for people who are proficient in the languages and tools used to be able to take on future maintenance tasks?”

“Process strictness: How important is it that the nominated development process and coding procedure is followed? In other words, is anyone going to be sacked if they don’t follow the identified processes?
Standards compliance: How important is it to comply with the various relevant standards?”


Comments
“Comment to supplement the source code.”
“Comment to explain the unusual.”
“Comment to document hardware/software interactions.”
“Comment with maintenance in mind.”


“Understand Principles behind Practices”


“Use Aggregate Objects to Reduce Coupling

”

Method Structure

“Keep each method as short as possible: 15 lines of code is a reasonable upper limit that you should be wary of ”

“limit that you should be wary of exceeding.
Give each method a single responsibility: If you are trying to give a meaningful name to the method and you find the name contains an <code />and</code>, there is a good chance that you are breaking this rule.
Declare methods with the lowest number of parameters possible: If you need more than 3 parameters it could be a good idea to do a small refactor by grouping them as properties of a single object.
Avoid nested loops or conditions where possible: You can improve both readability and reusability by putting them in little separated methods.
Write comments only when strictly necessary and keep them in sync with the code: There is nothing more useless than a comment that explains what you can easily read from the code or more ”



Predictability

Establish a set of shared coding standards: Programmers can understand a piece of code faster if they don’t encounter unexpected surprises while reading it.

keep in mind that the code should be readable by the next person debugging the code, even ourself after six months.







Don’t forget to write (good) code comments.
  Try to write good code first (and tests!).
  Try to write a one-sentence comment.
  Refactor the code (make it easier).
  Delete unnecessary comments.
  Rewrite bad comments
  (all good writing requires rewriting)
  Add detail where needed





  Object oriented design principle 1 -  DRY (Don't repeat yourself) 
  Object oriented design principle 2 - Encapsulate what varies
  Object oriented design principle 3 - Open Closed principle
  Object oriented design principle 4 - Single Responsibility Principle (SRP)
  Object oriented design principle 5 - Dependency Injection or Inversion principle
  Object oriented design principle 6 - Favour Composition over Inheritance
  Object oriented design principle 7 - Liskov Substitution Principle (LSP)
  Object oriented design principle 8 - Interface Segregation principle (ISP)
  Object oriented design principle 9 - Programming for Interface not implementation
  Object oriented design principle 10 - Delegation principle
